# 面向对象编程

## 什么是面向对象？
我们都知道[-[Java]-]是一门面向对象的语言，但是却很少去了解什么是**面向对象**。一种常见的回答是**数据与函数的组合**、另一种常见的回答是**面向对象编程是一种对真实世界进行建模的方式**，最后有人会说满足**封装**、**继承**和**多态**等语言特性的就是面向对象编程。

但这些说明只是从面向对象的语言中提出了一部分来解释，最终还是逃避了关键的问题：**面向对象编程究竟是什么？**

我经常听说**封装**、**继承**和**多态**是[-[Java]-]的三大语言特性。但是了解过类似于C这种面向过程的编程语言可以知道这些语言特性并不是[-[Java]-]这类面向对象的编程语言所独有的，甚至在某一方面，面向过程的比面向对象的语言做的更好。这样一来就更加模糊了这两类语言的边界，那么**面向对象编程究竟有什么好处？**

## 多态
> 多态：同一个行为具有多个不同表现形式或形态的能力。

编程语言一般都具有对于IO的操作，我们通过同一个接口就可以对不同的外设进行操作，这就是所说的多态。举个例子：
````C
struct FILE{
    void (*open)(char* name,int mode);
    void (*close)();
}

struct Device1{
    void (*open)(char* name,int mode);
    void (*close)();
}

void device1_open(char* name,int mode){

}
void device1_close(){

}
void init_device1(struct Device1 *device){
    (*device).open = device1_open;
    (*device).close = device1_close;
}
int main(void){
    struct Device1 device;
    struct FILE *file = (struct FILE*)&device;
    init_device(&device);
    (*file).open();
    (*file).close();
    return 0;
}
````

不清楚上面的例子能不能运行，但是以上代码想要表达的是[-[C]-]语言可以通过函数指针来实现多态，对于没有指针概念的[-[Java]-]来说，多态可以简单的理解为**父类的引用指向子类对象**。归根到底，多态就是函数指针的一种应用。面向对象编程语言虽然在多态上没有理论创新，但是它也确实让多态更安全、更便于使用。

对于直接使用函数指针显示实现多态的语言来说，最大的问题在于函数指针的危险性。因为函数指针的调用依赖于人为的约定，程序员必须严格按照固定约定来初始化函数指针，并同样严格按照约定来调用这些指针。从上面代码可以看出，[-[FILTE]-]与[-[Device1]-]之间没有任何关系，只是依靠人们之间的约定要实现其中相同的函数，如果之后的某个结构实现没有遵守这项规定，那么在调用的时候就会出现问题。

而对于[-[Java]-]来说，要实现多态就一定会使用到接口，通过接口强制使得程序员实现某些方法，这就大大提高安全性。

## 依赖反转

![控制流](/img/ControllStream.png)

在实现程序的业务逻辑时，我们会根据不同的逻辑将其划分为不同的功能实现然后组合在一起：高层函数调用一些中层函数，这些中层函数又继续调用一些底层函数（类似上图）。也就是说源代码层面的依赖不可避免的要跟随程序的控制流（业务逻辑）。

> 业务逻辑决定了控制流，而控制流决定了源代码依赖关系

但是使用多态就不一样了：

![多态](/img/polymorphism.png)

从上图可以看出，此时源代码中的调用并不是具体的实现类而是接口，也就是说相关方法的调用要等到运行时才知道。此时实现类与接口之间的关系方向和控制流正好相反，我们可以将其称之为**依赖反转**。通过这种方式，程序员可以完全控制采用了面向对象这种编程方式的系统中所有的源代码依赖关系，而不在受到系统控制流的限制。

这种依赖反转的好处就是在面向抽象编程，各个部分可以分开开发，使得程序的可维护性和可扩展性都得到了极大的提高。

## 结尾

> 面向对象编程：就是以多态为手段来对源代码的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。

## 参考资料

* 架构简洁之道